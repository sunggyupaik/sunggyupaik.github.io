---
layout: post
title:  "객체지향의 사실과 오해"
date:   2020-04-22
---
# 1. 협력하는 객체들의 공동체
객체지향의 목표는 실세계를 모방하는 것이 아니다. 오히려 새로운 세계를 창조하는 것이다.

객체는 다른 객체의 명령에 복종하는 것이 아니라 요청에 응답 할 뿐이다.
어떤 방식으로 응답할지는 객체 스스로 판단하고 결정한다. 심지어 요청에 응할지 여부도 객체 스스로 결정할 수 있다.

객체가 무엇(what)을 수행하는지 알 수 있지만 어떻게(how)수행아는지에 대해서는 알 수 없다.

과거에는 데이터와 프로세스를 엄격하게 구분한다.
객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다.
이것이 전통적인 개발 방법과 객체지향을 구분 지는 가장 핵심적인 차이다.

메시지를 수신한 객체가 실행 시간에 메서드를 선택할 수 있다는 점은 다른 프로그래밍 언어와 구분된다.
프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.

객체지향 선구자들의 초기 의도와 달리 대부분의 사람들은 객체지향을 클래스를 지향하는 것으로 생각했다.
많은 사람들이 UML의 가장 대표적인 다이어그램으로 클래스 다이어그램으로 꼽는다.

클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 분명하지만,
객체지향의 핵심을 이루는 중심 개념이라고 말하기에는 무리가 있다.

자바스크립트 같은 프로토타입 기반의 객체지향 언어에서는 **클래스가 존재하지** 않고 오직 객체만이 존재한다.
또한 상속 역시 클래스가 아닌 객체 간의 위임 메커니즘을 기반으로 한다.

지나치게 클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시킨다.

객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 
코드를 담는 클래스 관점에서 **메시지를 주고 받는 객체의 관점으로 사고의 중심을 전환하는 것이다.**

중요한 것은 어떤 클래스가 필요한가가 아니라 **어떤 객체들이 어떤 메시지를 주고받으며 협력하는가**이다.
클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다.

널리 알려신 미신과 달리 객체지향의 핵심은 클래스가 아니다. 
클래스는 협력에 참영하는 객체를 만드는 데 필요한
구현 메커니즘일 뿐이다.

객체지향의 중심에는 **클래스가 아니라 객체**가 위치하며, 
중요한 것은 **클래스들의 정적인 관계가 아니라 메시지를 주고받는 객체들의 동적 관계**다.
객체의 역할, 책임, 협력에 집중하라

# 2. 이상한 나라의 객체

객체란 인간이 분명하게 인지하고 구별할 수 있는 물리적인 또는 **개념적인** 경계를 지닌 어떤 것이다.
**주문**과 **계좌 이체**는 비록 물리적인 실체는 존재하지 않더라도 
인간이 쉽게 구분하고 하나의 단위로 인지할 수 있는 개념적인 객체의 일종이다.

현실 세계에서는 사람이 직접 주문 금액을 계산하지만, **소프트웨어 세계에서는 주문 객체가 자신의 금액을 계산한다.**
자동차가 스스로 시동을 걸고 통장이 스스로 금액을 인출하는 세상을 상상해 보라.

숫자, 문자열, 양, 속도, 시간, 날짜, 참/거짓과 같은 단순한 값들은 객체가 아니다.
그 자체로 독립적인 의미를 가지기보다는 다른 객체의 특성을 표현하는데 사용된다.

객체는 자율적인 존재라는 점을 명심하자. 
**객체지향이 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다.**
자율적인 객체는 스스로 자신의 상태를 책임져야 한다. 

외부의 객체가 직접적으로 객체의 상태를 주무를 수 없다면 간접적으로 객체의 상태를 변경하거나 조회할 수 있는 방법이 필요하다.

객체는 **스스로의 행동에 의해서만 상태가 변경되는 것을 보장**함으로써 객체의 자율성을 유지한다.
객체지향의 기본 사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는 것이라는 점을 기억하라.

* 캡슐화
객체지향의 세계에서 모든 객체는 **자신의 상태를 스스로 관리**하는 자율적인 존재다. 앨리스 객체의 키를 작게 만드는 것이 앨리스 자신인 것처럼 음료 객체의 양을 줄이는 것은 음료 자신이어야 한다. 앨리스는 직접적으로 음료의 상태를 변경할 수 없다. 단지 음료에게 자신이 음료를 마셨다는 메시지를 전달할 수 있을 뿐이다. 적절한 정도로 음료의 양을 줄이는 것은 메시지를 전달받은 음료 스스로의 몫이다.

캡슐화가 의미하는 것은 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다. 

객체가 외부에 노출하는 것은 행동뿐이며,
**외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동**뿐이다.

객체의 행동을 유발하는 것은 외부로부터 전달된 메시지지만 객체의 상태를 변경할지 여부는 객체 스스로 결정한다.
사실 객체에게 메시지를 전달하는 외부의 객체는 메시지를 수신하는 객체의 상태가 변경된다는 사실조차 알지 못한다.
**메시지를 해석하고 그에 반응해서 상태를 변경할지 여부는 전적으로 메시지 수신자의 자율적인 판단에 따른다.**
송신자가 상태 변경을 기대하더라도 수신자가 자신의 상태를 변경하지 않는다면 송신자가 간섭할 수 있는 어떤 여지도 없다.

상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.
1.캡슐화 저해 2. 객체가 고립 3. 객체의 재상용성 저하

협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다.
객체의 행동은 객체가 협력에 참여하는 유일한 방법이다.

행동을 결정한 후에야 행동에 필요한 정보가 무엇인지를 고려하게 되며 이 과정에서 필요한 상태가 결정된다.
우리가 애플리케이션 안에서 어떤 행동을 원하느냐가 어떤 객체가 적합한지를 결정한다.
객체의 적합성을 결정하는 것은 상태가 아니라 객체의 행동이다.


