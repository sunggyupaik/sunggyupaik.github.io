---
layout: post
title:  "객체지향의 사실과 오해<3,4>"
date:   2020-04-23
---

# 3.타입과 추상화 

해리 벡이 창조한 지하철 노선도의 핵심은 지도가 당연히 가져야 한다고 생각되는 ~~'정확성'~~을 버리고 그 **'목적'** 에 집중한 결과다. 지형 정보를 제거한 이유는 역의 위치가 중요한 것이 아니라 **역과 역 사이의 연결 관계**가 중요했던 것이다.

추상화의 목적은 불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복하는 것이다.

추상화는 복잡한 현실을 단순화하기 위해 사용하는 인간의 가장 기본적인 인지 수단이라고 할 수 있다.

리처드 파인만 " 현상은 복잡하다. 법칙은 단순하다. 버릴 게 무엇인지 알아내라."


객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 **인스턴스**라고 한다.


**분류**란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때,
우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다. 


타입 시스템의 목적은 메모리 안의 모든 데이터가 비트열로 보임으로써 야기되는 혼란을 방지하는 것이다.

타입 시스템의 목적은 데이터가 잘못 사용되지 않도록 제약사항을 부과하는 것이다.

객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 새로운 데이터 타입을 선언하는 것과 같다.

그렇다면 **객체는 데이터인가?** 그렇지 않다. 다시 한번 강조하지만 객체에서 중요한 것은 **객체의 행동**이다. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐이다. **객체를 창조할 때 가장 중요하게 고려해야 하는 것은 객체가 이웃하는 객체와 협력하기 위해 어떤 행동을 해야 할지를 결정하는 것이다.** 즉, 객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다. 

1. 어떤 객체가 어떠 타입에 속하는지 결정하는 것은 객체가 수행하는 행동이다.

2. 객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.

**어떤 객체를 다른 객체와 동일한 타입으로 분류하는 기준은 무엇인가?** 그 객체가 타입에 속한 다른 객체와 동일한 행동을 하기만 하면 된다. 그 객체가 어떤 데이터를 가지고 있는지 우리의 관심사가 아니다. 즉, 같은 타입에 속한 객체는 행동만 동일하다면 서로 다른 데이터를 가질 수 있다. 내부의 데이터 표현 방식이 다르더라도 동일한 메세지를 수신하고 이를 처리할 수 있다. 다만 내부의 표현 방식이 다르더라도 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다. (다형성)

다형성이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다. 다형적인 객체들은 동일한 타입에 속하게 된다. 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다.

행동에 따라 객체를 분류하기 위해서는 ~~객체가 내부적으로 관리해야 하는 데이터~~가 아니라 **객체가 외부에 제공해야 하는 행동을 먼저 생각해야 한다.** 이를 위해서 객체가 외부에 제공해야 하는 책임을 먼저 결정하고 그 책임을 수행하는 데 적합한 데이터를 나중에 결정한 후, 데이터ㄹㄹ 채김을 수행하는 데 필요한 외부 인터페이스 뒤로 캡슐화해야 한다.

객체를 결정하는 것은 행동이다. 데이터는 단지 행동을 따를 뿐이다. 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

**일반화는 추상화를 위한 도구다**

**왜 타입을 사용해야 하는가?** 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기 너무 어렵기 때문이다.

**타입은 추상화다.** 시간에 따라 동적으로 변하는 앨리스의 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. 어떤 시점에 애리스에 관해 생각할 때 불필요한 시간이라는 요소와 상태변화라는 요소를 제거하고 철저하게 정적인 관점에서 앨리스의 모습을 묘사하는 것이 가능하다.

타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다. 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.

동적 모델과 정적 모델을 적절히 혼용해야 한다.

**클래스와 타입은 동일한가?** 아니다. 타입은 객체를 분류하기 위해 사용하는 개념이고 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다. 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다. 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.

객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이다. 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스다.

# 4. 역할, 책임, 협력

객체지향에 갓 입문한 사람들의 가장 흔한 실수는 **협력이라는 *문맥*을 고려하지 않은 채 객체가 가져야 할 상태와 행동부터 고민하기 시작한다는 것이다.** 중요한 것은 개별 객체가 아니라 객체들 사이에 이뤄지는 **협력**이다. 훌륭한 객체지향 설계자는 **협력**에 초점을 맞춰 애플리케이션을 설계한다.

객체의 모양을 빚는 것은 객체가 참여하는 협력이다. 어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고, 필요한 행동이 객체의 상태를 결정한다. 개별적인 객체의 행동이나 상태가 아니라 객체들 간의 협력에 집중하라.

**책임과 메시지의 수준이 같은가?** 아니다. 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변화할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.

즉, 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다. 어떤 클래스가 필요하고 어떤 메서드를 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.

**어떤 객체라도 '판사'나 '증인'의 역할을 대체할 수 있을까?** 아니다. 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해할 수 있는 개체로 한정된다. 즉, 동일한 역할을 수행하는 객체들이 동일한 메세지를 수신할 수 있기 때문에 동일한 책임을 수행할 수 있다는 것은 매우 중요한 개념이다.

객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다는 점에 주목하라. 객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다. 결국 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다. 역할이 협력을 추상적으로 만들 수 있는 이유는 역할 자체가 객체의 추상화이기 때문이다.

"왕-하얀 토끼- 모자장수", "왕-하얀 토끼-요리사"의 협력을 보면, 구체적인 객체로 추상적인 역할을 대체해서 동일한 구조의 협력을 다양한 문맥에서 재사용할 수 있는 능력이 있으며 과거의 전통적인 패러다임과 구분되는 객체지향만의 힘이다. 그 힘은 근본적으로 역할의 대체 가능성에서 비롯된다.

 **시스템에 필요한 데이터를 저장하기 위해서 객체가 존재하는가?** 물론 객체가 상태의 일부로 데이터를 포함하는 것은 사실이지만 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다. 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다.
 
 **객체지향이 클래스와 클래스 간의 관계를 표현에 중점을 두는가?** 중요한 것은 클래스가 아니라 협력에 참여하는 *동적인 객체*이며, 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘이다. 객체지향의 핵심은 ~~클래스를 어떻게 구현할 것인가가 아니라~~객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이다.
 
 객체를 협력이라는 문맥에서 뗴어놓은 채 어떤 데이터가 필요하고 어떤 클래스로 구현해야 하는지를 고민하는 것이 아무런 도움이 되지 않는다
 
 **객체를 섬으로 바보던 관점을 어떻게 바꿀 것인가?**
 
 협력이라는 문맥에서 객체가 수행하게 될 적절할 책임, 즉 행동을 결정한 후에 그 행동을 수행하는 데 필요한 데이터를 고민해야 한다. 그리고 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느정도 결정된 후에 클래스의 구현 방법을 결정해야 한다. 결과적으로 클래스와 데이터는 협력과 책임의 집합이 결정된 후에야 무대 위에 등장할 수 있다.
 
 책임-주도설계는 개별적인 객체의 상태가 아니라 책임과 상호작용에 집중한다. 
 
 디자인패턴에서 중요한 것은 구성 요소의 클래스와 메서드가 아니라 '협력'에 참여하는 '역할'과 '책임'이라는 사실이다.
 
 테스트-주도 개발은 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하라고 충고한다. 그러나 이 같은 종류의 충고는 역할, 책임, 협력의 관점에서 객체를 바라보지 않을 경우 무의미하다.
 
 **테스트-주도 개발이 어떤 식으로 작동하는가?** 대부분의 사람들이 책임과 협력의 관점에서 객체를 바라보는 훈련이 부족하다. 테스트-주도 개발은 테스트를 작성하는 것이 아니라 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 *메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대*를 코드의 형태로 작성하는 것이다.
 
 
 
